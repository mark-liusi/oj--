# segmentation fault
当测试样例中出现运行错误，就我目前遇到的情况来讲，数组越界访问以及指针越界访问的情况居多。所以说在写对于数组的循环遍历的代码时，一定要注意对于首尾进行异常处理，具体情况还得具体分析。不要考虑完理论之后在算法上觉得不存在越界的可能，就不去考虑。
本题出现了多处运行错误的地方。
第一处，在第19行的数组初始化处，之前只设置了20个数字的数组，导致了4,7样例的错误。
第二处在第80行，之前一直在考虑链表接下来的越界，但是从没考虑过开头就有可能发生越界，亏我还看了文档中提示了全是"_"的输入样例了，到最后才翻然醒悟过来，一进行实验，果然发生了错误，正是越界，所以说，我们要做好异常的处理，也就是越界处理。

# 解题思路
这道题由于出到了栈与队列这一章之中，那么我的思路就自然而然就往栈上靠拢。栈的话，就存在入栈与出栈的操作，我意识到每次面积的产生都是由于“/”的出现，那么每有一个“/”的出现，我就可以使前一个“\”出栈。对于面积的计算，我将其视为梯形的计算，那么就需要知道底的大小，就拿最复杂的图中面积为19的为例，如果要求最上面的，也就是最大的梯形的面积，它的底要求的话就一定要有记录，所以一定要有存储，栈是要求对先前进行提取的，因此我不使用链表，使用数组，这就是di数组的来历，存储先前“\”的位置，然后与后面相应的“/”下标相对应。每有一个对应，我就相应的生成一个面积区域先进行记录下来。由于涉及到最后的合并面积，因此我们这里要记录每个面积的左面的标志和右面的标志，因此我的结构体设计为四个方面：面积，左，右，面积和指针。
接下来就是面积的合并，得益于我的面积是顺序的，因此我可以使用指针一直遍历下去。这里我参考了一下文档，引用一下：如果两个面积，一个下标是[j, k]另一个是[i, g]如果有j>i，k< g，那么这两个面积是可以合并的。所以我进行遍历，如果下一个的下表包含此时的，那么就让当前为0，面积合并给下一个。如果一次就结束的话，会出现和并不完全的情况，所以我们采用递归的思路，确保在我们的新链表中都合并完毕，不存在面积为0的情况。至此这道题就做完了。