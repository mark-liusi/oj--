# 思路
这道题感觉没什么特别的思路，首先我们需要确定一下它的生成情况是什么样的，我发现是一条边能生成四条边，所以我就知道了我需要多少vector的空间，那么接下来就是如何去算其他点的坐标，我的思路是通过线来算，线由两个点坐标构成，因此建立一个结构体，然后每个点是由横纵坐标构成的，需要在建立一个结构体，然后根据前几道题给的提示，没必要去递归，只需要搞一个循环，然后每次建立一个临时的vector来存储上一个得到的c，然后将c清理，对临时vector中的每条线运算，运算后的结果存储在c中，这里我用pushback就行。然后本道题不太重要但是也挺重要的一点就是我们要知道如何通过一条线的两个坐标来计算5个坐标，然后将它们作为4条线录入即可。
# vector的相关函数的用法
代码               算法复杂度    返回值类型   含义
c.front()         O(1)         引用        返回容器中的第一个数据
c.back()          O(1)         引用        返回容器中的最后一个数据
c.at(idx)                       引用        返回 c[idx]，会进行边界检查（越界报错）
c.size()          O(1)                    返回实际数据个数（unsigned类型）
c.begin()         O(1)         迭代器      返回首元素的迭代器（地址）
c.end()           O(1)         迭代器      返回最后一个元素后一个位置的迭代器（地址）
c.empty()         O(1)         bool       判断是否为空（空→true，非空→false）
c.reserve(sz)                             为数组提前分配 sz 的内存大小
c.assign(beg,end)                         将 [beg, end] 区间内容拷贝到容器
c.assign(n,val)                           将 n 个 val 值拷贝到容器
c.pop_back()      O(1)                    删除最后一个数据
c.push_back(ele)  O(1)                    在尾部添加一个数据
c.emplace_back(e) O(1)                    在尾部构造元素（比 push_back 高效）
c.clear()         O(N)                    清除容器中所有元素
c.resize(n,v)                             改变容器大小为 n，新元素初始化为 v
c.insert(pos,x)   O(N)                    在迭代器 pos 位置插入元素 x
c.erase(first,last) O(N)                  删除 [first, last] 区间的所有元素

记得c.end()和c.back()的用法
如果有了迭代器，想要知道其对应的值，那么需要使用*来解引用，就想用指针一样。

# 保留小数
调用#include<iomanip>，在输出中使用fixed和setprecision(8)就可以。